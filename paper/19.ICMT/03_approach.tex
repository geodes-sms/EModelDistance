\subsection{Running example}\label{sec:example}

\begin{figure}
    \centering
    \includegraphics[width=.8\linewidth]{images/pacman_example}
    \caption{The initial and target models of a Pacman game configuration}
    \label{fig:example}
\end{figure}
%
We rely on the running example of a simplified Pacman game, a well-known game where Pacman navigates through grid nodes searching for food to eat, while ghosts try to kill him.
We implemented a DSL to define game configurations, based on~\cite{Syriani2013a}.
\Fig{fig:example} illustrates two Pacman game models in the concrete syntax of the DSL.
Pacman, food, and ghosts are placed on grid nodes with an \texttt{on} reference.
Grid nodes are connected by \texttt{left}, \texttt{right}, \texttt{up}, and \texttt{down} references to define the permissible navigation of Pacman and ghosts.
The concrete syntax represents references by topological alignment rather than arrows.
Pacman is on grid node 21 which has an \texttt{up} reference to grid node 11 and a \texttt{right} reference to grid node 22.
A score object keeps track of the number of food Pacman eats.
We define the operational semantics of the DSL in terms of an inplace model transformation, implemented with graph transformation rules as in~\cite{Syriani2013a}.
One rule represents Pacman eating food on a grid node and updating the score.
Another represents the ghost killing Pacman when they are on the same grid node.
Four rules for Pacman and four others for the ghost represent moving in each direction to an adjacent grid node.\es{should we show one rule in Henshin?}
Although the rules should obey certain scheduling, \eg killing has priority over moving to end the game, in this work we assume that the transformation is a graph grammar \ie any rule can be applied at any time during the execution of the transformation\es{do we need this assumption?}.

Our goal is to find the minimal sequence of rule applications starting from the initial model leading to the target model.
Search-based techniques are very useful to solve this problem.
They explore all possibilities of the search-space by generating intermediate models as a result of applying the rules while optimizing the objective to get closer to the target model.
For the example in \Fig{fig:example}, a minimal rule sequence is Pacman moves up once, then moves right three times, each time eating the food.
The ghost also moves left twice.
\es{In current approaches? cite?}To compute the difference between the two models, a generic model comparison tool, like EMFCompare, would report that three food objects are deleted, two \texttt{on} references (Pacman and ghost) are changed, and the attribute value of the score is modified.
This information is not precise enough to identify the minimal sequence of rules.
For example, if Pacman moves right first, then he will have to go through the top center grid node at least twice.
Common model difference approaches rely solely on changes in the abstract syntax.
However, the comparison needs to be tailored to both the DSL and its semantics to find the best rule sequence.
In this example, the notion of Pacman and ghost movements must be encoded in the comparison.
Inplace model transformation rules typically encode semantic operations, such as operational semantics or refactoring~\cite{Lucio2016}.
Therefore, we propose a set of domain-specific distance metrics that take into consideration abstract syntax changes as well as the semantics of the transformation to optimize the search space of identifying the minimal sequence of rule applications.
%
%\es{to be used where needed}\begin{itemize}
%    \item[Regular difference results:]
%        3 food objects deleted ;
%        2 on references modified ;
%        1 score value attribute modified.
%    
%    \item[Distance results:]
%        Move distance is $3+2=5$ ;
%        Value distance is $\frac{|4-1|}{4}=0.75$ ;
%        Element distance is $\frac{3+0}{13+10}=0.13$.
%    
%    \item[Minimal rules applied:]
%        1 Pacman Move Up ;
%        2 Pacman Move Right ;
%        3 Pacman Eats Food ;
%        2 Ghost Move Left.
%\end{itemize}

\subsection{Model distance metrics}

Typical model difference tools report metrics on elements added and deleted in terms of instances of metamodel classes, on references changed in terms of instances of metamodel associations, and on attribute value modifications.
For our purpose, we need metrics that are tailored to the DSL both in terms of the metamodel and the semantics of the transformation.
Therefore, we propose the following three model distance metrics.
These metrics are measured between two models M1 and M2, where M2 is the result of applying a sequence of rules on M1.

The semantics of many formalisms relies on movements of model elements.
Some of their elements are \emph{movable} while others represent \emph{positions} where an element can move to.
For example, Pacman moves on the grid in our example, attributes move to superclasses in class diagrams, or tokens move between places in a Petri net.
Furthermore, some elements are \emph{modifiable} meaning that the transformation changes some of their attribute values, like the score in the rule Pacman Eats Food.

Formally, we represent a model as a labeled, attributed multi-graph $G=\langle V,E,l,a \rangle$.
We identify three subsets of nodes $Mov,Pos,Mod \subset V$ corresponding to the movable, position, and modifiable objects.
In our running example, grid nodes are the position nodes and Pacman and ghosts are movable nodes.
Note that, in general, $Pos$ may be different for each $v \in Mov$.
Additionally, all three subsets need not to be disjoint nor complete: an object can move between positions, but it can also serve as position for other movable objects, and it can have attributes modified.
Among the set of edges $e:V \rightarrow V \in E$, we identify two subsets $N,P \subset E$.
Neighbor edges $n: Pos \rightarrow Pos \in N$ only connect position nodes, \eg \texttt{left}, \texttt{right}, \texttt{up}, and \texttt{down} references between grid nodes.
Position edges $p: Mov \rightarrow Pos \in P$, like the \texttt{on} references, connect a movable node to a position node.
The label function $l:V \rightarrow \Sigma^*$ assigns a unique string label to each node.
The attribute function $a:V \times \Sigma^* \rightarrow \mathbb{N}$ assigns numerical values to each attribute name of a node.
%$w:Pos \rightarrow \mathbb{N}$ assigns numerical weight to each position edge.

\subsubsection{Move distance}
The move distance of a movable object is the length of the shortest path from its position in model M1 to its position in model M2.
We define $\delta_M(v_1,v_2)$ as the length of the shortest sequence of neighbor edges connecting $v_1$ to $v_2 \in Pos$.
In \Fig{fig:example}, $\delta_M(pacman,grid_{13})=3$ and $\delta_M(ghost,grid_{21})=2$, which is equivalent to the Manhattan distance in this grid layout.
To compute the move distance between M1 and M2, we identify the common connected subgraph $G_{12}$ of their respective graphs $G_1$ and $G_2$.
We define the move distance between two models as:
\[
\Delta_M(G_1,G_2)=\sum_{v_1,v_2 \in Mov_{12}}{\delta_M(p(v_1),p(v_2))} \mbox{, where } l(v_1)=l(v_2)
\]
Here, $p(v_1)$ is the position of $v_1$ in $G_1$ and $p(v_2)$ is its corresponding position in $G_2$.
In our example, $\Delta_M(M1,M2)=5$.
We rely on the popular Floyd-Warshall algorithm~\cite{Floyd1962,Warshall1962} to compute the shortest path between two nodes in a connected graph.
The dynamic programming implementation takes $O(|Pos|^3)$ to compute all distances between any two nodes and $O(|N|)$ to output the path.


\subsubsection{Element distance}
This metric is concerned with the presence and absence of metamodel class instances between M1 and M2.
This is similar to what a model difference algorithm outputs.
We define the element distance as:
\[
\Delta_E(G_1,G_2)=\frac{|\{v \in V_1 | \nexists v_2 \in V_2, l(v_2)=l(v)\}|+|\{v \in V_2 | \nexists v_1 \in V_1, l(v_1)=l(v)\}|}{|V_1|+|V_2|}
\]
The numerator counts the number of nodes exclusively in each graph.
To normalize the distance as a ratio between 0 and 1, we divide by the total number of nodes in both graphs.
In our example, $\Delta_E(M1,M2)=\frac{3+0}{13+10}=0.13$.
We can interpret this distance as the ratio of objects added or removed between the two models.
In this particular case, 13\% of the objects in M1 have been removed in M2.
Note that the element distance is not concerned with edges, since they are already taken care of by the move distance.


\subsubsection{Value distance}
The third metric is concerned with the difference in attribute values between objects in M1 and M2.
We assume that any attribute value can be encoded as a unique number, a common practice for metrics~\cite{Bertoa2018}.
We define the value distance of attribute $x$ of node $v$ between $G_1$ and $G_2$ as:
\[
\delta_V(v,x)=\frac{|a(v,x)-a(v_1,x)|}{a(v,x)} \mbox{, where } v_1 \in Mod_1, v \in Mod_2 \mbox{ and } l(v)=l(v1)
\]
Here, we only consider attributes of objects present in both M1 and M2 because the element distance already takes care of absence and presence of elements.
This distance computes the margin of error needed to obtain the value of $x$ in $v$ from its value in $v_1$.
We define the value distance between two models as the average of $\delta_V$ for all attributes of all nodes in $G_{12}$.
This calculates the average margin of error between all attribute values of the two models.
In our example, $\Delta_V(M1,M2)=\delta_V(score,value)=\frac{|4-1|}{4}=0.75$.

%
%\begin{itemize}
%	\item[Move distance:] There is often movement of elements (\eg pacman moving on the grid, attributes moving around classes). The move distance of a movable object is the length of the shortest path from its position in M1 to its position in M2. Move distance is related to computing the difference with Ecore references.
%	\item[Element distance:] Is the difference in the presence/absence of elements in M1 and M2. The element distance is the ratio, between 0 and 1, of the number of differences with respect to the total number of objects in M1 and M2.
%	\item[Value distance:] Is the difference in attribute values between M1 and M2. We assume that any attribute type can be encoded as numbers. Then the value distance of attribute x is its margin of error: $|M2.x - M1.x| / M2.x$. In this case, M2 acts as the expected target.
%	
%\end{itemize}
%
%The \emph{Move distance} relies on the Floyd-Marshall algorithm that computes the shortest from any position element to any position element in an Ecore model. This code is in EcoreShortestPaths and is independent from the domain. Its only external dependency is an interface IEReferenceNavigator which provides a function that gives the neighbor(s) of a position element. DistanceUtil provides all the necessary methods the move distance requires.
%
%The \emph{Value distance} is an average of all attribute distances. We only consider attributes of objects present in both M1 and M2 because the element distance takes care of absence and presence of elements. We assume that any attribute value can be represented as a unique number, which is common~\cite{Bertoa2018}. DistanceUtil provides the toDouble method to perform that conversion. Currently, it only supports number values encoded as Number or String data types. For each attribute, we compute its margin of error.
%
%The \emph{Element distance} looks for the objects present in M1 but not M2 and M2 but not M1. This is then divided by the size of M1 and M2. We only consider objects instances of metamodel classes. So references and attributes are not taken into account in this measure. This distance relies on the unique ID of each object as returned by the getId method.
%
%DistanceCalculator is the abstract class at the root that should be inherited by your distance function. For example MoveDistance only relies on the move distance between M1 and M2.

\subsection{Generation of domain-specific metrics}

This implementation is just a proof of concept. It has been implemented with the mindset that the distance calculation is generated automatically from analyzing the metamodel and the transformation rules.

Given a metamodel MM and Henshin rules R, we want to generate the distance calculator that will be used by the MOMot script.

The domain-specific distance classes (e.g., the move, element, value distances) can be easily generated. They have two dependencies to the metamodel:

The package instance, by overriding the getEPackageInstance() function
The constructor, by instantiating the appropriate DistanceUtil singleton object specific to the metamodel

Only the utility class (e.g., PacmanDistanceUtil) must be generated after analyzing MM and R. Following the code in PacmanDistanceUtil should guide you to know how to generate the code. Here are special considerations:

Your Utility class must inherit from DistanceUtil.
It should import all movable, position, modifiable, and other classes.
It must provide a function used for its singleton instantiation as follows.

It should have 4 attributes for movable, position, modifiable, and all other types.

It should override all abstract methods from DistanceUtil.
The tricky part is the generation of the Object getId(EObject object) method. If each object has attribute with setID(true) you can rely on super. Otherwise, you have to make up one unique on your own. For example, if you know for sure that an attribute is unique, then you can rely on it (e.g., Places and Transitions in the Petrinet example). If there is only one possible instance of this element, then return true (e.g., Scoreboard in the Pacman example). It can also rely on an object it references or that references it (e.g., Food in the Pacman example).

You also need to generate the DistanceUtilFactory specific to the metamodel (e.g., PacmanGameDistanceUtilFactory). Its only purpose is to make the concrete DistanceUtil accessible as a singleton.

\subsubsection{Customization}

The only code that is specific to the metamodel is the class that implements DistanceUtil. This is where you define the functions that provide the following information:

\begin{itemize}
	\item[The movable objects:] An object is movable if, when analyzing the rules, it has a reference to a position object and the rules modify that reference. Note that it could also be that a position object references a movable object.
	\item[The position objects:] An object is a position if, when analyzing the rules, it is what movable objects are always linked to. Note that it could also be that a position object references a movable object.
	\item[The modifiable objects:] An object is modifiable if, when analyzing the rules, one of its attributes changes value.
	\item[The other objects:] Any object that is not movable, position or modifiable.
	\item[The ID of an object:] the value that uniquely identifies an object. This is used to find similar elements between M1 and M2.
	\item[The modifiable attributes:] All attribute values subject to modification for a given object.
	\item[Accessing the position:] the attribute used to know the position of a movable object.
	\item[Accessing the neighbors of a position:] the attribute used to connect position objects.
	\item[Accessing the root:] used to find the root object of M1 and M2.
\end{itemize}

\subsection{Genetic programming with domain-specific model distances}

\es{as a subsection or a section on its own. This is where we can talk about implementation: MOMot, Henshin, Ecore, etc.}

The idea is to generate the optimizing search problem to be tailored for the domain. In this sense, we customize the fitness function based on a distance metric. 
Multi-objective genetic programming with an objective function to minimize for each distance metric.
We also need to minimize the number of rule applications: the number of rules to apply to get from M1 to M2. This distance is already taken into account in MOMot and returns a positive integer.