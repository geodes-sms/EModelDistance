\subsection{Running example}\label{sec:example}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/pacman_example}
    \caption{The initial model M1 and two possible models resulting from applying different rules of the Pacman game}
    \label{fig:example}
\end{figure}
%
We rely on the running example of a simplified Pacman game, a well-known game where Pacman navigates through grid nodes searching for food to eat, while ghosts try to kill him.
We implemented a DSL to define game configurations, based on~\cite{Syriani2013a}.
\Fig{fig:example} illustrates two Pacman game models in the concrete syntax of the DSL\es{first use of acronym?}.
Pacman, food, and ghosts are placed on grid nodes with an \texttt{on} reference.
Grid nodes are connected by \texttt{left}, \texttt{right}, \texttt{up}, and \texttt{down} references to define the permissible navigation of Pacman and ghosts.
The concrete syntax represents references by topological alignment rather than arrows.
In M1, Pacman is on grid node 21 which has an \texttt{up} reference to grid node 11 and a \texttt{right} reference to grid node 22.
A score object keeps track of the points of every food Pacman eats.
The point for red food is 1 and for green food is 3.
We define the operational semantics of the DSL in terms of an inplace model transformation, implemented with graph transformation rules as in~\cite{Syriani2013a}.
One rule represents Pacman eating food on a grid node and updating the score.
Another represents the ghost killing Pacman when they are on the same grid node.
Four rules for Pacman and four others for the ghost represent moving in each direction to an adjacent grid node.\es{should we show one rule in Henshin?}
Although the rules should obey certain scheduling, \eg killing has priority over moving to end the game, in this work, we assume that the transformation is a graph grammar \ie any rule can be applied at any time during the execution of the transformation\es{do we need this assumption?}.

In this running example, we are interested in finding the minimal sequence of rule applications starting from the initial model leading to the target model.
Search-based techniques are very useful to solve this problem.
They explore all possibilities of the search-space by generating intermediate models as a result of applying the rules while optimizing the objective to get closer to the target model.
For example, a minimal rule sequence to go from M1 to M2 in \Fig{fig:example} is Pacman moves up once, then moves right three times, eating the food each time, while the ghost also moves left twice.
A minimal rule sequence from M1 to M3 is Pacman moves right, then up, then left, eating the food each time, while the ghost moves up once.

Detecting the rule sequence requires to compare models at every step.
\es{In current approaches? cite?}To compute the difference between M1 and M2, a generic model comparison tool, like EMFCompare, would report that three food objects are deleted, two \texttt{on} references (Pacman and ghost) are changed, and the attribute value of the score is modified.
This tool would report the same information when we compare M1 and M3.
However, a domain expert would immediately detect that the there is a clear difference betweem: 10 rules are needed to obtain M2 and 7 rules to obtain M3.
Furthermore, the score value hints to which type of food Pacman ate.
Thus, the information output by common model differencing approaches is not precise enough to identify the minimal sequence of rules (\eg for the M2 case, if Pacman moves right first, he will have to go through grid 12 node at least twice).
The main reason is that they rely solely on changes in the abstract syntax.
However, the comparison needs to be tailored to both the DSL and its semantics to find the best rule sequence.
In this example, relying on creation, deletion, and modification of elements of the metamodel is not sophisticated enough.
The notion of Pacman and ghost movements as well as a quantification of the score value must be encoded in the comparison.
Inplace model transformation rules typically encode semantic operations, such as operational semantics or refactoring~\cite{Lucio2016}.
Therefore, we propose a set of domain-specific distance metrics that take into consideration abstract syntax changes as well as the semantics of the transformation to provide more precise information when comparing models.
This would optimize the search space of identifying the minimal sequence of rule applications.
%
%\es{to be used where needed}\begin{itemize}
%    \item[Regular difference results:]
%        3 food objects deleted ;
%        2 on references modified ;
%        1 score value attribute modified.
%    
%    \item[Distance results:]
%        Move distance is $3+2=5$ ;
%        Value distance is $\frac{|4-1|}{4}=0.75$ ;
%        Element distance is $\frac{3+0}{13+10}=0.13$.
%    
%    \item[Minimal rules applied:]
%        1 Pacman Move Up ;
%        2 Pacman Move Right ;
%        3 Pacman Eats Food ;
%        2 Ghost Move Left.
%\end{itemize}

\subsection{Model distance metrics}

\es{some repetition with the end of the paragraph above}
Typical model difference tools report metrics on elements added and deleted in terms of instances of metamodel classes, on references changed in terms of instances of metamodel associations, and on attribute value modifications.
As motivated in \Sect{sec:example}, we need metrics that are tailored to the DSL both in terms of the metamodel and the semantics of the transformation.
Therefore, we propose the following three model distance metrics.
These metrics are measured between two models M1 and M2, where M2 is the result of applying a sequence of rules on M1\es{do we need to state that?}.

The semantics of many formalisms relies on movements of model elements.
Some of their elements are \emph{movable} while others represent \emph{positions} where an element can move to.
Pacman moving on the grid in our example, attributes moving to superclasses in class diagrams, or tokens moving between places in a Petri net are some of many examples where it happens.
Furthermore, some elements are \emph{modifiable} meaning that the transformation changes some of their attribute values, like the score in the rule where Pacman eats food.

Formally, we represent a model as a labeled, attributed multi-graph $G=\langle V,E,l,a \rangle$.
We identify three subsets of nodes $Mov,Pos,Mod \subseteq V$ corresponding to the movable, position, and modifiable objects in the model.
In our running example, grid nodes are the position nodes while Pacman and ghosts are movable nodes.
Note that, in general, $Pos$ may be different for each $v \in Mov$.
Additionally, all three subsets need not to be disjoint nor complete: an object can move between positions, but it can also serve as a position for other movable objects, and it can have attributes modified.
Among the set of edges $e:V \rightarrow V \in E$, we identify two subsets $N,P \subseteq E$.
Neighbor edges $n: Pos \rightarrow Pos \in N$ only connect position nodes, \eg \texttt{left}, \texttt{right}, \texttt{up}, and \texttt{down} references between grid nodes.
Position edges $p: Mov \rightarrow Pos \in P$, like the \texttt{on} references, connect a movable node to a position node.
The label function $l:V \rightarrow \Sigma^*$ assigns a unique string label to each node.
The attribute function $a:V \times \Sigma^* \rightarrow \mathbb{N}$ assigns numerical values to each attribute name of a node.
%$w:Pos \rightarrow \mathbb{N}$ assigns numerical weight to each position edge.

\subsubsection{Move distance}
The move distance of a movable object is the length of the shortest path from its position in model M1 to its position in model M2.
We define $\delta_M(v_1,v_2)$ as the length of the shortest sequence of neighbor edges connecting $v_1$ to $v_2 \in Pos$.
In the M2 case in \Fig{fig:example}, $\delta_M(pacman,grid_{13})=3$ and $\delta_M(ghost,grid_{21})=2$, which is equivalent to the Manhattan distance in this grid layout.
To compute the move distance between M1 and M2, we identify the common connected subgraph $G_{12}$ of their respective graphs $G_1$ and $G_2$.
We define the move distance between two models as:
\[
\Delta_M(G_1,G_2)=\sum_{v_1,v_2 \in Mov_{12}}{\delta_M(p(v_1),p(v_2))} \mbox{, where } l(v_1)=l(v_2)
\]
Here, $p(v_1)$ is the position of $v_1$ in $G_1$ and $p(v_2)$ is its corresponding position in $G_2$.
In our example, $\Delta_M(M1,M2)=5$ and $\Delta_M(M1,M3)=2$.
We rely on the popular Floyd-Warshall algorithm~\cite{Floyd1962,Warshall1962} to compute the shortest path between two nodes in a connected graph.
The dynamic programming implementation takes $O(|Pos|^3)$ to compute all distances between any two nodes and $O(|N|)$ to output the path.


\subsubsection{Element distance}
This metric is concerned with the presence and absence of metamodel class instances between M1 and M2.
This is similar to what a model difference algorithm outputs.
We define the element distance as:
\[
\Delta_E(G_1,G_2)=\frac{|\{v \in V_1 | \nexists v_2 \in V_2, l(v_2)=l(v)\}|+|\{v \in V_2 | \nexists v_1 \in V_1, l(v_1)=l(v)\}|}{|V_1|+|V_2|}
\]
The numerator counts the number of nodes exclusively in each graph.
To normalize the distance as a ratio between 0 and 1, we divide by the total number of nodes in both graphs.
In our example, $\Delta_E(M1,M2)=\frac{3+0}{13+10}=0.13$ and $\Delta_E(M1,M3)=0.13$.
We can interpret this distance as the ratio of objects added or removed between the two models.
In this particular case, 13\% of the objects in M1 have been removed in M2 and in M3.
Note that the element distance is not concerned with edges since they are already taken care of by the move distance.


\subsubsection{Value distance}
The third metric is concerned with the difference in attribute values between objects in M1 and M2.
We assume that any attribute value can be encoded as a unique number, a common practice for metrics~\cite{Bertoa2018}.
We define the value distance of attribute $x$ of node $v$ between $G_1$ and $G_2$ as:
\[
\delta_V(v,x)= \left\{
    \begin{array}{lr}
        |a(v_1,x)| & \mbox{if } a(v,x)=0   \\
        |a(v,x)-a(v_1,x)|/a(v,x) & \mbox{otherwise}
    \end{array}
    \right.
\]
where $v_1 \in Mod_1, v \in Mod_2 \mbox{ and } l(v)=l(v1)$.
Here, we only consider attributes of objects present in both M1 and M2 because the element distance already takes care of the absence and presence of elements.
This distance computes the margin of error needed to obtain the value of $x$ in $v$ from its value in $v_1$.
Note that if $a(v,x)=0$ we replace the denominator by 1.
We define the value distance $\Delta_V(G1,G2)$ between two models as the average of $\delta_V$ for all attributes of all nodes in $G_{12}$.
This calculates the average margin of error between all attribute values of the two models.
In our example, $\Delta_V(M1,M2)=\delta_V(score,value)=\frac{|4-1|}{4}=0.75$ and $\Delta_V(M1,M3)=0.86$.

Typically, if a model difference tool reports the same changes in M2 and M3, the element distance will be the same for both cases as well.
However, the move and value distance will typically discriminate the two as we have seen in the Pacman example.
Furthermore, distance metrics provide a quantitative appreciation of the difference in terms of \emph{``how far''} (thus, comparison distance) M1 is from M2.


\subsection{Adapting distance metrics to the DSL}

The distance metrics presented in \Sect{sec:metrics} are generic model distances to compare two models.
We now describe how to adapt these metrics for a particular DSL and its semantics.
We aim to produce a distance calculator given the metamodel of the DSL and a set of inplace model transformation rules encoding its semantics.
Typically, these rules have a precondition and a postcondition pattern.

We need to identify the metamodel classes corresponding to the sets of nodes $Pos$ and $Mov$, and the associations corresponding to the sets of edges $N$ and $P$.
The potential candidates for $Mov$ are classes that have an association to another class in the metamodel with cardinality at most 1.
We denote $A$ the potentially movable class and $r$ its association to the other class $B$.
Instances of $A,r,$ and $B$ must be in the precondition of a rule and $r$ must be modified in the postcondition to reference another class instance.
Then, potentially $A$ is a class of movable nodes, $r$ is a position edge type, and $B$ is a class of position nodes.
In our example, these are, among others, the \texttt{Pacman} class, the \texttt{on} association, and the \texttt{GridNode} class, respectively.
It is also possible that $r$ is an association from $B$ to $A$.
Furthermore, it may be that the second instance $A$ refers to is of another type than $B$, say $C$.
If there is a reference $s$ between $B$ and $C$, then $s$ is likely to be a neighbor edge.
Note that this is a necessary condition but not sufficient.
For example, it may be the case where the movable and position classes are connected directly but through an intermediate class.

Similarly, we analyze the classes of the metamodel such that one of its attribute value is modified in the postcondition of a rule.
Such classes define the type of the nodes in $Mod$.

The three distance metrics rely on the label function $l$ to correspond similar nodes between the two models.
For example in \Fig{fig:example}, the grid nodes are identified by their identifier (\eg 11, 12, \ldots).
However, not all classes in the metamodel of the DSL have an identifying attribute.
Since the label function must uniquely identify each node, we must compute a label for each object that does not have one.
We can compute the label structurally.
For example, we can ascertain that there is at most one food on a grid node.
Then the label of a food object can rely on the label of the grid node it is on.
Another case is if we can ascertain that a class is a singleton, then we assign the same label to its instance.

From the above, we understand that automatically adapting the distance metrics to the DSL is very challenging.
Therefore, we implemented the distance metrics as a Java library \texttt{EModelDistance} that can compute the metrics on any Ecore model in the Eclipse Modeling Framework.
The library encapsulates all dependencies on the metamodel of the DSL within one abstract class \texttt{DistanceUtility}.
The developer must override the five sets $Pos,Mov,Mod,N,$ and $P$ for his DSL.
He must also define the \texttt{getId()} function for each class of the metamodel, if it does not already have an identity attribute.
