package PacmanGame.search;

import java.io.File;
import java.util.Iterator;
import java.util.ArrayList;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import PacmanGame.GridNode;
import PacmanGame.PacmanGamePackage;
import PacmanGame.PositionableEntity;
import PacmanGame.impl.FoodImpl;
import PacmanGame.impl.GameImpl;
import PacmanGame.impl.MoveableEntityImpl;

public class EMFCompareDistanceCalculator extends DistanceCalculator {
	
	private EObject targetModel;
	
	public EMFCompareDistanceCalculator(File targetModel) {
		super(targetModel);
	}
	
	@Override
	protected EPackage getEPackageInstance() {
		return PacmanGamePackage.eINSTANCE;
	}
	
	@Override
	public double calculateDistance(EObject model) {
		double diff_food = 0.0, diff_score = 0.0, diff_moveable = 0.0, distance_moveable = 0.0;
		try {
			// re-load resource to avoid multi-threading issues
			//reloadResource(first);
			synchronized (this.targetModel) {
				synchronized (model) {
					GameImpl src = (GameImpl)model;
					GameImpl tar = (GameImpl)this.targetModel;
					long src_food = src.getEntites().stream().filter(e -> e instanceof FoodImpl).count(),
							tar_food = tar.getEntites().stream().filter(e -> e instanceof FoodImpl).count();
					long max_food = Math.max(src_food, tar_food);
					if (max_food > 0) {
						diff_food = Math.abs(src_food - tar_food) / max_food;
					}
					/*diff_score = Math.abs(src.getScoreboard().getScore() - tar.getScoreboard().getScore());
					if (diff_score > 0)
					{
						diff_score = 1 / diff_score;	// to get a number in [0,1]
					}*/
					// Diff and distance pacmans
					int entityCount = 0;
					int gridCount = tar.getGridnodes().size();
					for (Iterator<PositionableEntity> iter = tar.getEntites().stream().filter(e -> e instanceof MoveableEntityImpl).iterator(); iter.hasNext(); ) {
						PositionableEntity tar_entity = iter.next();
						String id = tar_entity.getId();
						ArrayList<PositionableEntity> entities = new ArrayList<PositionableEntity>();
						for (PositionableEntity e : src.getEntites())
						{
							if ((e instanceof MoveableEntityImpl) && e.getId().equals(id))
							{
								entities.add(e);
							}
						}
						if (entities.size() == 1) {
							distance_moveable += 1.0 * INSTANCE.manhattanDistance(entities.get(0), tar_entity) / gridCount;
							//System.out.println("Id: " + id + " ; Dist: " + distance_moveable + " ; Grid: " + gridCount);
						}
						else {
							diff_moveable++;	// this pacman or ghost is missing
						}
						entityCount++;
					}
					if (entityCount > 0) {
						diff_moveable /= entityCount;
					}
				}
			}
			//distance = (diff_food + diff_score + diff_moveable + distance_moveable) / 4;
			distance = (diff_food + diff_moveable + distance_moveable) / 3;
			//distance = Math.pow(distance, 2); // ... to decrease smaller parts??
			finished = true;
			//System.out.println("Food: " + diff_food + " ; Entities: " + diff_moveable + " ; Dist: " + distance_moveable + " ; Distance: " + distance);
			
		} catch (Exception e) {
			distance = 1.0;
			System.err.println("Error: " + e.getMessage());
			e.printStackTrace();
		}
		return distance;
	}

	public int manhattanDistance(PositionableEntity source, GridNode target) throws Exception
	{
		int src_x = getX(source.getOn()),
			src_y = getY(source.getOn()),
			tar_x = getX(target),
			tar_y = getY(target);
		return Math.abs(tar_x-src_x) + Math.abs(tar_y-src_y);
	}
	public int manhattanDistance(PositionableEntity source, PositionableEntity target) throws Exception
	{
		int src_x = getX(source.getOn()),
			src_y = getY(source.getOn()),
			tar_x = getX(target.getOn()),
			tar_y = getY(target.getOn());
		//int d = Math.abs(tar_x-src_x) + Math.abs(tar_y-src_y);
		//System.out.println(source.getId() + " on " + source.getOn().getId() + " should be on " + target.getOn().getId() + " distance=" + d);
		return Math.abs(tar_x-src_x) + Math.abs(tar_y-src_y);
	}
	
	public int getX(GridNode node) throws Exception
	{
		return _getHalfString(node.getId(), true);
	}
	
	public int getY(GridNode node) throws Exception
	{
		return _getHalfString(node.getId(), false);
	}
	
	private int _getHalfString(String s, boolean first) throws Exception
	{
		int size = s.length();
		if (size % 2 != 0)
			throw new Exception("Incorrect ID format for grid node " + s);
		String x;
		if (first)
			x = s.substring(0, size/2);
		else
			x = s.substring(size/2, size);
		try
		{
			return Integer.parseInt(x);
		}
		catch (Exception e)
		{
			throw new Exception("ID is not a number for grid node " + s); 
		}
	}
}
package PacmanGame.search;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Map;
import java.util.Stack;

import org.apache.commons.io.output.NullOutputStream;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.compare.Comparison;
import org.eclipse.emf.compare.EMFCompare;
import org.eclipse.emf.compare.Match;
import org.eclipse.emf.compare.scope.DefaultComparisonScope;
import org.eclipse.emf.compare.scope.IComparisonScope;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.emf.henshin.interpreter.EGraph;
import org.moeaframework.core.Solution;

import PacmanGame.PacmanGamePackage;
import at.ac.tuwien.big.moea.search.fitness.IFitnessEvaluation;
import at.ac.tuwien.big.momot.problem.solution.TransformationSolution;
import icmt.tool.momot.demo.PacmanSearch;

public class EMFCompareDistanceCalculator{
	
	private EObject targetModel;
	private File targetModelFile;
	
	public EMFCompareDistanceCalculator(File targetModel) {
		try {
		this.targetModelFile = targetModel;
		ResourceSet test = new ResourceSetImpl();
		this.targetModel = loadModel(targetModel.getAbsolutePath());
		this.ecomp = EMFCompare.builder().build();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private boolean finished;
	private EMFCompare ecomp;
	private double matches;
	public double getMatches() {
		return matches;
	}

	public double getDifferences() {
		return differences;
	}
	
	public boolean isFinished() {
		return finished;
	}

	public double getDistance() {
		return distance;
	}

	private double differences;
	private double distance;
	
	private String firstResourceName;
	public String getFirstResourceName() {
		return firstResourceName;
	}

	public String getSecondResourceName() {
		return secondResourceName;
	}

	private String secondResourceName;
	
	private String firstResourcePath;
	public String getFirstResourcePath() {
		return firstResourcePath;
	}

	public String getSecondResourcePath() {
		return secondResourcePath;
	}
		public EObject loadModel(String uri) {
			// register XMI resource factory for .xmi extension
		Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE;
		Map<String, Object> m = reg.getExtensionToFactoryMap();
		m.put("xmi", new XMIResourceFactoryImpl());
		// create resource set
		ResourceSet resourceSet = new ResourceSetImpl();
		// register FSA metamodel
		resourceSet.getPackageRegistry().put(PacmanGamePackage.eINSTANCE.getNsURI(),
				PacmanGamePackage.eINSTANCE);
		// create file URI, always use File.getAbsolutePath()
		URI fileUri = URI.createFileURI(new File(uri).getAbsolutePath());
		// load resource
		Resource resource = resourceSet.getResource(fileUri, true);
		// retrieve first EObject in the resource
		return resource.getContents().get(0);
		}
	
	private String secondResourcePath;
	
	private static EMFCompareDistanceCalculator INSTANCE;
	
	public static void initWith(File modelFile) {
		INSTANCE = new EMFCompareDistanceCalculator(modelFile);
	}

	public static double calculateFitness(EObject model) {
		return INSTANCE.calculateDistance(model);
	}
	
	public  double calculateDistance(EObject model) {

		try {
			// re-load resource to avoid multi-threading issues
			//reloadResource(first);
			synchronized (this.targetModel) {
				synchronized (model) {
					IComparisonScope scope = new DefaultComparisonScope(this.targetModel, model, null);
					Comparison comp = ecomp.compare(scope);
					matches = 0;
					differences = 0;
					// Really simple, let's see how good it is
					// Decrease severity the lower you go
					for (Match m : comp.getMatches()) {
						++matches;
						double curWeight = 1.0;
						Stack<Stack<Match>> curMatches = new Stack();
						Stack<Match> curmStack = new Stack<Match>();
						curmStack.addAll(m.getSubmatches());
						curMatches.add(curmStack);
						while (!curMatches.isEmpty()) {
							Stack<Match> curStack = curMatches.peek();
							if (curStack.isEmpty()) {
								curMatches.pop();
								curWeight *= 2;
							} else {
								Match curMatch = curStack.pop();
								if (curMatch.getLeft() != null && curMatch.getRight() != null) {
									matches += curWeight;
								} else {
									differences += curWeight;
								}
			//					for (Diff diff : curMatch.getDifferences().size()) {
			//						// DifferenceKind kind = diff.getKind();
			//						differences += curWeight; 
			//					}
								differences += curWeight * curMatch.getDifferences().size();
								Stack<Match> subStack = new Stack<Match>();
								subStack.addAll(curMatch.getSubmatches());
								curMatches.push(subStack);
								curWeight *= 0.5;
							}
						}
					}
					distance = ((double) differences) / (matches + differences);
					distance = Math.pow(distance, 2); // ... to decrease smaller parts??
					finished = true;
				}
			}
			
		} catch (Exception e) {
			distance = 1.0;
			System.err.println("Error: "+e.getMessage());
			e.printStackTrace();
		}
		return distance;
	}
	public String getReportLine() {
		return "Distance between '" + firstResourceName + "' and '" + secondResourceName + "' is " + distance + " ("
				+ matches + "/" + differences + ")\n";
	}

}

