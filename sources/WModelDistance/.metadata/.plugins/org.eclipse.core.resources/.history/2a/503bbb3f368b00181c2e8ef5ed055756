package PacmanGame.search;

import java.io.File;
import java.util.Iterator;
import java.util.ArrayList;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import PacmanGame.GridNode;
import PacmanGame.PacmanGamePackage;
import PacmanGame.PositionableEntity;
import PacmanGame.impl.FoodImpl;
import PacmanGame.impl.GameImpl;
import PacmanGame.impl.MoveableEntityImpl;

public class EMFCompareDistanceCalculator extends DistanceCalculator {
	
	private EMFCompare ecomp;
	private double matches;
	public double getMatches() {
		return matches;
	}

	public double getDifferences() {
		return differences;
	}

	public double getDistance() {
		return distance;
	}

	private double differences;
	private double distance;
	
	public EMFCompareDistanceCalculator(File targetModel) {
		super(targetModel);
		try {
		this.ecomp = EMFCompare.builder().build();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	@Override
	protected EPackage getEPackageInstance() {
		return PacmanGamePackage.eINSTANCE;
	}
	
	@Override
	
	public  double calculateDistance(EObject model) {

		try {
			// re-load resource to avoid multi-threading issues
			//reloadResource(first);
			synchronized (this.targetModel) {
				synchronized (model) {
					IComparisonScope scope = new DefaultComparisonScope(this.targetModel, model, null);
					Comparison comp = ecomp.compare(scope);
					matches = 0;
					differences = 0;
					// Really simple, let's see how good it is
					// Decrease severity the lower you go
					for (Match m : comp.getMatches()) {
						++matches;
						double curWeight = 1.0;
						Stack<Stack<Match>> curMatches = new Stack();
						Stack<Match> curmStack = new Stack<Match>();
						curmStack.addAll(m.getSubmatches());
						curMatches.add(curmStack);
						while (!curMatches.isEmpty()) {
							Stack<Match> curStack = curMatches.peek();
							if (curStack.isEmpty()) {
								curMatches.pop();
								curWeight *= 2;
							} else {
								Match curMatch = curStack.pop();
								if (curMatch.getLeft() != null && curMatch.getRight() != null) {
									matches += curWeight;
								} else {
									differences += curWeight;
								}
			//					for (Diff diff : curMatch.getDifferences().size()) {
			//						// DifferenceKind kind = diff.getKind();
			//						differences += curWeight; 
			//					}
								differences += curWeight * curMatch.getDifferences().size();
								Stack<Match> subStack = new Stack<Match>();
								subStack.addAll(curMatch.getSubmatches());
								curMatches.push(subStack);
								curWeight *= 0.5;
							}
						}
					}
					distance = ((double) differences) / (matches + differences);
					distance = Math.pow(distance, 2); // ... to decrease smaller parts??
					finished = true;
				}
			}
			
		} catch (Exception e) {
			distance = 1.0;
			System.err.println("Error: "+e.getMessage());
			e.printStackTrace();
		}
		return distance;
	}
	
	public String getReportLine() {
		return "Distance between '" + firstResourceName + "' and '" + secondResourceName + "' is " + distance + " ("
				+ matches + "/" + differences + ")\n";
	}
}
import java.io.IOException;
import java.io.OutputStream;
import java.util.Map;
import java.util.Stack;

import org.apache.commons.io.output.NullOutputStream;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.compare.Comparison;
import org.eclipse.emf.compare.EMFCompare;
import org.eclipse.emf.compare.Match;
import org.eclipse.emf.compare.scope.DefaultComparisonScope;
import org.eclipse.emf.compare.scope.IComparisonScope;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.emf.henshin.interpreter.EGraph;
import org.moeaframework.core.Solution;

import PacmanGame.PacmanGamePackage;
import at.ac.tuwien.big.moea.search.fitness.IFitnessEvaluation;
import at.ac.tuwien.big.momot.problem.solution.TransformationSolution;
import icmt.tool.momot.demo.PacmanSearch;

public class EMFCompareDistanceCalculator{
	
	private EObject targetModel;
	private File targetModelFile;
	
	public EMFCompareDistanceCalculator(File targetModel) {
		try {
		this.targetModelFile = targetModel;
		ResourceSet test = new ResourceSetImpl();
		this.targetModel = loadModel(targetModel.getAbsolutePath());
		this.ecomp = EMFCompare.builder().build();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private boolean finished;
	private EMFCompare ecomp;
	private double matches;
	public double getMatches() {
		return matches;
	}

	public double getDifferences() {
		return differences;
	}
	
	public boolean isFinished() {
		return finished;
	}

	public double getDistance() {
		return distance;
	}

	private double differences;
	private double distance;
	
	private String firstResourceName;
	public String getFirstResourceName() {
		return firstResourceName;
	}

	public String getSecondResourceName() {
		return secondResourceName;
	}

	private String secondResourceName;
	
	private String firstResourcePath;
	public String getFirstResourcePath() {
		return firstResourcePath;
	}

	public String getSecondResourcePath() {
		return secondResourcePath;
	}
		public EObject loadModel(String uri) {
			// register XMI resource factory for .xmi extension
		Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE;
		Map<String, Object> m = reg.getExtensionToFactoryMap();
		m.put("xmi", new XMIResourceFactoryImpl());
		// create resource set
		ResourceSet resourceSet = new ResourceSetImpl();
		// register FSA metamodel
		resourceSet.getPackageRegistry().put(PacmanGamePackage.eINSTANCE.getNsURI(),
				PacmanGamePackage.eINSTANCE);
		// create file URI, always use File.getAbsolutePath()
		URI fileUri = URI.createFileURI(new File(uri).getAbsolutePath());
		// load resource
		Resource resource = resourceSet.getResource(fileUri, true);
		// retrieve first EObject in the resource
		return resource.getContents().get(0);
		}
	
	private String secondResourcePath;
	
	private static EMFCompareDistanceCalculator INSTANCE;
	
	public static void initWith(File modelFile) {
		INSTANCE = new EMFCompareDistanceCalculator(modelFile);
	}

	public static double calculateFitness(EObject model) {
		return INSTANCE.calculateDistance(model);
	}
	
	public  double calculateDistance(EObject model) {

		try {
			// re-load resource to avoid multi-threading issues
			//reloadResource(first);
			synchronized (this.targetModel) {
				synchronized (model) {
					IComparisonScope scope = new DefaultComparisonScope(this.targetModel, model, null);
					Comparison comp = ecomp.compare(scope);
					matches = 0;
					differences = 0;
					// Really simple, let's see how good it is
					// Decrease severity the lower you go
					for (Match m : comp.getMatches()) {
						++matches;
						double curWeight = 1.0;
						Stack<Stack<Match>> curMatches = new Stack();
						Stack<Match> curmStack = new Stack<Match>();
						curmStack.addAll(m.getSubmatches());
						curMatches.add(curmStack);
						while (!curMatches.isEmpty()) {
							Stack<Match> curStack = curMatches.peek();
							if (curStack.isEmpty()) {
								curMatches.pop();
								curWeight *= 2;
							} else {
								Match curMatch = curStack.pop();
								if (curMatch.getLeft() != null && curMatch.getRight() != null) {
									matches += curWeight;
								} else {
									differences += curWeight;
								}
			//					for (Diff diff : curMatch.getDifferences().size()) {
			//						// DifferenceKind kind = diff.getKind();
			//						differences += curWeight; 
			//					}
								differences += curWeight * curMatch.getDifferences().size();
								Stack<Match> subStack = new Stack<Match>();
								subStack.addAll(curMatch.getSubmatches());
								curMatches.push(subStack);
								curWeight *= 0.5;
							}
						}
					}
					distance = ((double) differences) / (matches + differences);
					distance = Math.pow(distance, 2); // ... to decrease smaller parts??
					finished = true;
				}
			}
			
		} catch (Exception e) {
			distance = 1.0;
			System.err.println("Error: "+e.getMessage());
			e.printStackTrace();
		}
		return distance;
	}
	public String getReportLine() {
		return "Distance between '" + firstResourceName + "' and '" + secondResourceName + "' is " + distance + " ("
				+ matches + "/" + differences + ")\n";
	}

}

