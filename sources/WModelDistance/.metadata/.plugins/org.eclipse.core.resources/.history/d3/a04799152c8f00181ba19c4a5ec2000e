package PacmanGame.search;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;

import PacmanGame.Ghost;
import PacmanGame.GridNode;
import PacmanGame.Pacman;
import PacmanGame.impl.GameImpl;


//FIXME: should implement an interface
public class PacmanDistanceUtil implements IDistanceUtil {
	// Singleton class
	private static PacmanDistanceUtil INSTANCE;
	
	private PacmanDistanceUtil() { }
	
	/*public static PacmanDistanceUtil getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new PacmanDistanceUtil();
		}
		return INSTANCE;
	}*/
	
	// Generated from EObject.eClass().getName()
	private static final Set<String> movableTypes = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("Pacman", "Ghost"))); 
	private static final Set<String> positionTypes = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("GridNode")));

	public Set<String> getMovableTypes() {
		return movableTypes;
	}

	public Set<String> getPositionTypes() {
		return positionTypes;

	public static Object getId(EObject object) {
		// Generated form metamodel
		if (object instanceof Pacman)
			return ((Pacman)object).getId();
		else if (object instanceof Ghost)
			return ((Ghost)object).getId();
		else if (object instanceof GridNode)
			return ((GridNode)object).getId();
		else
			return null;
	}

	public static EObject getPosition(EObject movable) {
		// Generated form metamodel
		if (movable instanceof Pacman)
			return ((Pacman)movable).getOn();
		else if (movable instanceof Ghost)
			return ((Ghost)movable).getOn();
		else
			return null;
	}

	//FIXME: Should override from an interface
	public static List<EObject> getPositionNeighbors(EObject position) {
		// Generated form metamodel
		ArrayList<EObject> neighbors = new ArrayList<EObject>(); 
		if (position instanceof GridNode) {
			neighbors.add(((GridNode)position).getTop());
			neighbors.add(((GridNode)position).getBottom());
			neighbors.add(((GridNode)position).getLeft());
			neighbors.add(((GridNode)position).getRight());
		}
		return neighbors;
	}
	
	public static List<EObject> getMovableObjects(EObject root) {
		// I should know the attributes used to connect a movable object to a target (or vice-versa)
		root = getRoot(root);
		return ((GameImpl)root).getEntites().stream().filter(
			e -> getMovableTypes().contains(e.eClass().getName())).collect(Collectors.toList());
	}
	
	public static List<EObject> getPositionObjects(EObject root) {
		// I should know the attributes used to connect target objects
		root = getRoot(root);
		return ((GameImpl)root).getGridnodes().stream().filter(
				e -> getPositionTypes().contains(e.eClass().getName())).collect(Collectors.toList());
	}
	
	public static EObject getMovableInModel(EObject movable, EObject model) {
		// I should know the attributes used to connect target objects
		model = getRoot(model);
		for (EObject mov : getMovableObjects(model)) {
			if (getId(movable).equals(getId(mov))) {
				return mov;
			}
		}
		return null;
	}
	
	public static EObject getPositionInModel(EObject position, EObject model) {
		// I should know the attributes used to connect target objects
		model = getRoot(model);
		for (EObject pos : getPositionObjects(model)) {
			if (getId(position).equals(getId(pos))) {
				return pos;
			}
		}
		return null;
	}
	
	private static EObject getRoot(EObject o) {
		if (!(o instanceof GameImpl)) {
			o = EcoreUtil.getRootContainer(o);
		}
		return o;
	}
}
